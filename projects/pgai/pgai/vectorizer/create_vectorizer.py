"""This file is generated by the configuration generator
in generate/config_generator.py. Do not modify by hand."""

from dataclasses import dataclass
from typing import Any

# Dynamic imports based on parameter types
from .configuration import (
    ChunkingCharacterTextSplitterConfig,
    ChunkingRecursiveCharacterTextSplitterConfig,
    EmbeddingOllamaConfig,
    EmbeddingOpenaiConfig,
    EmbeddingVoyageaiConfig,
    FormattingPythonTemplateConfig,
    IndexingDefaultConfig,
    IndexingDiskannConfig,
    IndexingHnswConfig,
    IndexingNoneConfig,
    ProcessingDefaultConfig,
    SchedulingDefaultConfig,
    SchedulingNoneConfig,
    SchedulingTimescaledbConfig,
    SQLArgumentMixin,
)


@dataclass
class CreateVectorizer:
    """Parameters for ai.create_vectorizer function"""

    source: str
    destination: str | None = None
    embedding: (
        EmbeddingOllamaConfig | EmbeddingOpenaiConfig | EmbeddingVoyageaiConfig | None
    ) = None
    chunking: (
        ChunkingCharacterTextSplitterConfig
        | ChunkingRecursiveCharacterTextSplitterConfig
        | None
    ) = None
    indexing: (
        IndexingDefaultConfig
        | IndexingDiskannConfig
        | IndexingHnswConfig
        | IndexingNoneConfig
        | None
    ) = None
    formatting: FormattingPythonTemplateConfig | None = None
    scheduling: (
        SchedulingDefaultConfig
        | SchedulingNoneConfig
        | SchedulingTimescaledbConfig
        | None
    ) = None
    processing: ProcessingDefaultConfig | None = None
    target_schema: str | None = None
    target_table: str | None = None
    view_schema: str | None = None
    view_name: str | None = None
    queue_schema: str | None = None
    queue_table: str | None = None
    grant_to: Any | None = None
    enqueue_existing: bool | None = None

    def to_sql(self) -> str:
        """Convert parameters to SQL function call"""
        parts = ["SELECT ai.create_vectorizer("]

        parts.append(f"'{self.source}'::regclass")

        # Handle all config objects that implement SQLArgumentMixin
        for field_name, field_value in self.__dict__.items():
            if isinstance(field_value, SQLArgumentMixin):
                parts.append(field_value.to_sql_argument())
            elif field_value is not None and field_name not in ("source",):
                # Handle primitive types
                if isinstance(field_value, bool):
                    parts.append(f", {field_name} => {str(field_value).lower()}")
                elif isinstance(field_value, list):
                    values = ",".join(f"'{v}'" for v in field_value)  # type: ignore
                    parts.append(f", {field_name} => ARRAY[{values}]")
                else:
                    parts.append(f", {field_name} => '{field_value}'")

        parts.append(")")
        return "\n".join(parts)
