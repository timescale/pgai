"""This file is generated by the configuration generator
in generate/config_generator.py. Do not modify by hand."""

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, ClassVar, TypeAlias

JsonDict: TypeAlias = dict[str, Any]


def format_sql_params(params: dict[str, str | None | bool | list[str]]) -> str:
    """Format dictionary of parameters into SQL argument string without any quoting."""
    formatted: list[str] = []
    for key, value in params.items():
        if value is None:
            continue
        elif isinstance(value, bool):
            formatted.append(f"{key}=>{str(value).lower()}")
        elif isinstance(value, list):
            array_list = ",".join(f"E'{v}'" for v in value)
            formatted.append(f"{key}=>ARRAY[{array_list}]")
        elif isinstance(value, timedelta):
            formatted.append(f"{key}=>'{value.seconds} seconds'")
        else:
            formatted.append(f"{key}=> '{value}'")
    return ", ".join(formatted)


class SQLArgumentMixin:
    arg_type: ClassVar[str]
    function_name: ClassVar[str]

    def to_sql_argument(self) -> str:
        params = {}
        for field_name in self.__dataclass_fields__:  # type: ignore
            if field_name != "arg_type" and field_name != "function_name":
                value = getattr(self, field_name)  # type: ignore
                if value is not None:
                    params[field_name] = value

        return f", {self.arg_type} => {self.function_name}({format_sql_params(params)})"  # type: ignore


@dataclass
class ChunkingCharacterTextSplitterConfig(SQLArgumentMixin):
    """Configuration for ai.chunking_character_text_splitter function."""

    arg_type: ClassVar[str] = "chunking"
    function_name: ClassVar[str] = "ai.chunking_character_text_splitter"

    chunk_column: str
    chunk_size: int | None = None
    chunk_overlap: int | None = None
    separator: str | None = None
    is_separator_regex: bool | None = None


@dataclass
class ChunkingRecursiveCharacterTextSplitterConfig(SQLArgumentMixin):
    """Configuration for ai.chunking_recursive_character_text_splitter function."""

    arg_type: ClassVar[str] = "chunking"
    function_name: ClassVar[str] = "ai.chunking_recursive_character_text_splitter"

    chunk_column: str
    chunk_size: int | None = None
    chunk_overlap: int | None = None
    separators: list[str] | None = None
    is_separator_regex: bool | None = None


@dataclass
class EmbeddingOllamaConfig(SQLArgumentMixin):
    """Configuration for ai.embedding_ollama function."""

    arg_type: ClassVar[str] = "embedding"
    function_name: ClassVar[str] = "ai.embedding_ollama"

    model: str
    dimensions: int
    base_url: str | None = None
    options: dict[str, Any] | None = None
    keep_alive: str | None = None


@dataclass
class EmbeddingOpenaiConfig(SQLArgumentMixin):
    """Configuration for ai.embedding_openai function."""

    arg_type: ClassVar[str] = "embedding"
    function_name: ClassVar[str] = "ai.embedding_openai"

    model: str
    dimensions: int
    chat_user: str | None = None
    api_key_name: str | None = None


@dataclass
class EmbeddingVoyageaiConfig(SQLArgumentMixin):
    """Configuration for ai.embedding_voyageai function."""

    arg_type: ClassVar[str] = "embedding"
    function_name: ClassVar[str] = "ai.embedding_voyageai"

    model: str
    dimensions: int
    input_type: str | None = None
    api_key_name: str | None = None


@dataclass
class FormattingPythonTemplateConfig(SQLArgumentMixin):
    """Configuration for ai.formatting_python_template function."""

    arg_type: ClassVar[str] = "formatting"
    function_name: ClassVar[str] = "ai.formatting_python_template"

    template: str | None = None


@dataclass
class IndexingDefaultConfig(SQLArgumentMixin):
    """Configuration for ai.indexing_default function."""

    arg_type: ClassVar[str] = "indexing"
    function_name: ClassVar[str] = "ai.indexing_default"


@dataclass
class IndexingDiskannConfig(SQLArgumentMixin):
    """Configuration for ai.indexing_diskann function."""

    arg_type: ClassVar[str] = "indexing"
    function_name: ClassVar[str] = "ai.indexing_diskann"

    min_rows: int | None = None
    storage_layout: str | None = None
    num_neighbors: int | None = None
    search_list_size: int | None = None
    max_alpha: float | None = None
    num_dimensions: int | None = None
    num_bits_per_dimension: int | None = None
    create_when_queue_empty: bool | None = None


@dataclass
class IndexingHnswConfig(SQLArgumentMixin):
    """Configuration for ai.indexing_hnsw function."""

    arg_type: ClassVar[str] = "indexing"
    function_name: ClassVar[str] = "ai.indexing_hnsw"

    min_rows: int | None = None
    opclass: str | None = None
    m: int | None = None
    ef_construction: int | None = None
    create_when_queue_empty: bool | None = None


@dataclass
class IndexingNoneConfig(SQLArgumentMixin):
    """Configuration for ai.indexing_none function."""

    arg_type: ClassVar[str] = "indexing"
    function_name: ClassVar[str] = "ai.indexing_none"


@dataclass
class ProcessingDefaultConfig(SQLArgumentMixin):
    """Configuration for ai.processing_default function."""

    arg_type: ClassVar[str] = "processing"
    function_name: ClassVar[str] = "ai.processing_default"

    batch_size: int | None = None
    concurrency: int | None = None


@dataclass
class SchedulingDefaultConfig(SQLArgumentMixin):
    """Configuration for ai.scheduling_default function."""

    arg_type: ClassVar[str] = "scheduling"
    function_name: ClassVar[str] = "ai.scheduling_default"


@dataclass
class SchedulingNoneConfig(SQLArgumentMixin):
    """Configuration for ai.scheduling_none function."""

    arg_type: ClassVar[str] = "scheduling"
    function_name: ClassVar[str] = "ai.scheduling_none"


@dataclass
class SchedulingTimescaledbConfig(SQLArgumentMixin):
    """Configuration for ai.scheduling_timescaledb function."""

    arg_type: ClassVar[str] = "scheduling"
    function_name: ClassVar[str] = "ai.scheduling_timescaledb"

    schedule_interval: timedelta | None = None
    initial_start: datetime | None = None
    fixed_schedule: bool | None = None
    timezone: str | None = None
