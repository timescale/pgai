--FEATURE-FLAG: text_to_sql

-------------------------------------------------------------------------------
-- render_semantic_catalog_sql
create or replace function ai.render_semantic_catalog_sql(id bigint, sql text, description text) returns text
as $func$
    select concat_ws
    ( E'\n'
    , format('<sql-example id=%s>', id)
    , sql
    , format('/* %s */', description)
    , '</sql-example>'
    )
$func$ language sql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- _render_semantic_catalog_obj_desc
create or replace function ai._render_semantic_catalog_attr_desc(id bigint, classid oid, objid oid) returns text
as $func$
declare
    _classid oid = _render_semantic_catalog_attr_desc.classid;
    _objid oid = _render_semantic_catalog_attr_desc.objid;
    _description text;
begin
    -- find descriptions of the table/view itself and columns of the table/view
    -- the table/view itself has an objsubid = 0
    -- columns have objsubid > 0
    -- prefer descriptions from the semantic catalog, fallback to COMMENTs
    with x as
    (
        select
          f.attname -- null for the table/view itself
        , coalesce(a.objsubid, b.objsubid) as objsubid
        , coalesce(a.description, b.description) as description
        from
        (
            select x.objsubid, x.description
            from ai.semantic_catalog_obj x
            where x.classid = _classid
            and x.objid = _objid
        ) a
        full outer join
        (
            select d.objsubid, d.description
            from pg_catalog.pg_description d
            where d.classoid = _classid
            and d.objoid = _objid
        ) b
        on (a.objsubid = b.objsubid)
        left outer join pg_catalog.pg_attribute f -- left outer b/c the table/view itself won't have a row in pg_attribute
        on (f.attrelid = _objid and f.attnum = coalesce(a.objsubid, b.objsubid))
    )
    select string_agg
    (
        format
        ( '/* %s %s */'
        , coalesce(x.attname, '')
        , x.description
        )
    , E'\n' order by x.objsubid
    )
    into _description
    from x
    where x.description is not null -- shouldn't be the case but paranoia strikes deep
    ;
    return _description;
end
$func$ language plpgsql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- _render_semantic_catalog_table
create or replace function ai._render_semantic_catalog_table(id bigint, classid oid, objid oid) returns text
as $func$
declare
    _classid oid = _render_semantic_catalog_table.classid;
    _objid oid = _render_semantic_catalog_table.objid;
    _nspname pg_catalog.name;
    _relname pg_catalog.name;
    _persistence pg_catalog.text;
    _columns pg_catalog.text[];
    _constraints pg_catalog.text[];
    _indexes pg_catalog.text;
    _ddl text;
    _description text;
begin
    -- get the descriptions (if any) of the table and the columns of the table
    select ai._render_semantic_catalog_attr_desc(id, _classid, _objid)
    into _description
    ;

    -- names
    select
      n.nspname
    , k.relname
    , case k.relpersistence
        when 't' then 'TEMPORARY'
        when 'u' then 'UNLOGGED'
        else ''
      end
    into strict
      _nspname
    , _relname
    , _persistence
    from pg_catalog.pg_class k
    inner join pg_catalog.pg_namespace n
    on (k.relnamespace operator(pg_catalog.=) n.oid)
    where k.oid operator(pg_catalog.=) objid
    ;

    -- columns
    select pg_catalog.array_agg(x.txt order by x.attnum)
    into strict _columns
    from
    (
        select pg_catalog.concat_ws
        ( ' '
        , a.attname
        , pg_catalog.format_type(a.atttypid, a.atttypmod)
        , case when a.attnotnull then 'NOT NULL' else '' end
        , case
            when a.atthasdef
                then pg_catalog.pg_get_expr(d.adbin, d.adrelid)
            when a.attidentity operator(pg_catalog.=) 'd'
                then 'GENERATED BY DEFAULT AS IDENTITY'
            when a.attidentity operator(pg_catalog.=) 'a'
                then 'GENERATED ALWAYS AS IDENTITY'
            when a.attgenerated operator(pg_catalog.=) 's'
                then pg_catalog.format('GENERATED ALWAYS AS (%s) STORED', pg_catalog.pg_get_expr(d.adbin, d.adrelid))
            else ''
          end
        ) as txt
        , a.attnum
        from pg_catalog.pg_attribute a
        left outer join pg_catalog.pg_attrdef d
        on (a.attrelid operator(pg_catalog.=) d.adrelid and a.attnum operator(pg_catalog.=) d.adnum)
        where a.attrelid operator(pg_catalog.=) objid
        and a.attnum operator(pg_catalog.>) 0
        and not a.attisdropped
    ) x;

    -- constraints
    select pg_catalog.array_agg(pg_catalog.pg_get_constraintdef(k.oid, true) order by k.conname)
    into _constraints
    from pg_catalog.pg_constraint k
    where k.conrelid operator(pg_catalog.=) objid
    ;

    -- indexes
    select coalesce(pg_catalog.string_agg(pg_catalog.pg_get_indexdef(i.indexrelid, 0, true), E';\n'), '')
    into strict _indexes
    from pg_catalog.pg_index i
    where i.indrelid operator(pg_catalog.=) objid
    ;

    -- ddl
    select pg_catalog.format(E'CREATE %s TABLE %I.%I\n( ', _persistence, _nspname, _relname)
    operator(pg_catalog.||)
    pg_catalog.string_agg(x.line, E'\n, ')
    operator(pg_catalog.||)
    E'\n);\n'
    operator(pg_catalog.||) coalesce(_indexes, '')
    into strict _ddl
    from
    (
        select * from pg_catalog.unnest(_columns) line
        union all
        select * from pg_catalog.unnest(_constraints) line
    ) x
    ;

    if _ddl is null then
        return '';
    end if;

    return concat_ws
    ( E'\n'
    , format('<table id=%s>', id)
    , _ddl
    , coalesce(_description, '')
    , '</table>'
    );
end
$func$ language plpgsql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- _render_semantic_catalog_view
create or replace function ai._render_semantic_catalog_view(id bigint, classid oid, objid oid) returns text
as $func$
declare
    _classid oid = _render_semantic_catalog_view.classid;
    _objid oid = _render_semantic_catalog_view.objid;
    _ddl text;
    _description text;
begin
    -- get the descriptions (if any) of the view and the columns of the view
    select ai._render_semantic_catalog_attr_desc(id, _classid, _objid)
    into _description
    ;

    -- get the ddl for the view
    select pg_catalog.pg_get_viewdef(_objid, true)
    into _ddl
    ;

    if _ddl is null then
        return '';
    end if;

    return concat_ws
    ( E'\n'
    , format('<view id=%s>', id)
    , _ddl
    , coalesce(_description, '')
    , '</view>'
    );
end
$func$ language plpgsql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- _render_semantic_catalog_func
create or replace function ai._render_semantic_catalog_func(id bigint, classid oid, objid oid) returns text
as $func$
declare
    _classid oid = _render_semantic_catalog_func.classid;
    _objid oid = _render_semantic_catalog_func.objid;
    _ddl text;
    _description text;
begin
    select x.description into _description
    from ai.semantic_catalog_obj x
    where x.classid = _classid
    and x.objid = _objid
    and x.objsubid = 0
    ;
    if _description is null then
        select d.description into _description
        from pg_catalog.pg_description d
        where d.classoid = _classid
        and d.objoid = _objid
        and d.objsubid = 0
        ;
    end if;

    select pg_catalog.pg_get_functiondef(_objid) into _ddl;

    if _ddl is null then
        return '';
    end if;

    return concat_ws
    ( E'\n'
    , format('<function id=%s>', id)
    , _ddl
    , coalesce(_description, '')
    , '</function>'
    );
end
$func$ language plpgsql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- render_semantic_catalog_obj
create or replace function ai.render_semantic_catalog_obj(id bigint, classid oid, objid oid) returns text
as $func$
    select
        case k.relname
            when 'pg_class' then
                case
                    when k.relkind in ('r', 'p') then
                        ai._render_semantic_catalog_table(id, classid, objid)
                    when k.relkind in ('v', 'm') then
                        ai._render_semantic_catalog_view(id, classid, objid)
                    else ''
                    end
            when 'pg_proc' then
                ai._render_semantic_catalog_func(id, classid, objid)
            else ''
        end
    from pg_catalog.pg_class k
    where k.oid = classid
$func$ language sql stable security invoker
set search_path to pg_catalog, pg_temp
;

-------------------------------------------------------------------------------
-- render_obj_sample
create or replace function ai.render_sample
( relation pg_catalog.regclass
, total int default 5
) returns text
as $python$
    #ADD-PYTHON-LIB-DIR
    import ai.semantic_catalog
    return ai.semantic_catalog.render_sample(plpy, relation, total)
$python$
language plpython3u volatile parallel safe security invoker
set search_path to pg_catalog, pg_temp
;
